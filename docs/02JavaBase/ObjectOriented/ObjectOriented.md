面向对象
========

思想
----

### 概念：

面向对象是一种常见的程序结构设计方法。

面向对象思想的基础是将相关的数据和方法放在一起，组合成一种信的复合数据类型，然后使用新创建的复合数据类型作为项目的基础。

面向对象是一个很抽象的概念，它相对面向过程而言。

过程与独享都是一种解决问题的思想。

面向过程，强调的是功能行为，一种过程，先干什么，后干什么。

面向独享：将功能封装到对象里，强调的是具备某功能的对象。

按照面向对象的思想，可以把任何的东西看做对象。

面向对象的三个特征：封装，继承，多态。

### 总结：

面向过程强调的是具体功能的实现(执行者)

面向对象是具备功能的对象(管理者)

面向过程：c语言 什么事都自己做

面向对象：c++ , java , c\# , ruby ,python 什么事都指挥对象去做

### 特点：

1：将复杂的事情简单化。

2：面向对象将以前的过程中的执行者，变成了指挥者。

3：面向对象这种思想是符合现在人们思考习惯的一种思想。

过程和对象在我们的程序中是如何体现的呢？过程其实就是方法；对象是将方法等一些内容进行了封装。

### 类和对象    

-   类是对象的抽象描述，对象是类的具体实现      

-   计算机的执行代码的顺序是从main入口开始，从上往下依次执行  

### 类

类是java语言的最小编程单位，也是设计和实现java程序的基础。

概念：

是一组事物共有特征和功能的描述，对一组事物的总体描述，是按照面向对象技术进行设计时最小的单位，也是组成项目的最基本的模块。类的概念是抽象的，类似于建筑设计中的图纸，是对于现实需要代表的具体内容的抽象。类只包含框架结构，而不包含具体数据。所以类代表的是总体，而不是某个特定的个体。

总结：类是抽象的，对象实实在在存在的具体个体。

-   自定义的类都是引用数据类型（相当于设计图纸）

-   类包括方法（对象具有的行为）和属性（对象具有的特征）

-   类不是对象，但是类是对象抽象的描述，是类的蓝图，，它会告诉jvm如何创建某种类型对象

-   类只能包含实例变量（属性）和方法，对变量进行操作只能放在方法中去操作

-   一个类可以创建多个对象            

-   并不是所有的类都具有属性和方法

### 方法：

-   将功能相同的代码进行封装

-   调用者不用关心方法内部的实现

-   在方法中声明的叫局部变量

-   当方法有多个参数时，调用者需传入符合条件的参数列表（正确的顺序，类型，数量）

-   **普通的类方法和构造方法的唯一区分就是构造方法没有返回值**

### 对象：

-   具体的东西

-   是类的具体体现（实例）        

-   一般把对象称之为实例。属性称之为实例变量

-   java中所有定义的基本类型或对象都必须初始化才能输出值

-   要想使用类中定义的属性和方法，必须先声明类的对象，通过对象.属性或者对象.方法()来实现调用，方法后要加(),属性不用

### 属性：

-   通过属性区分对象的不同，也叫实例变量

-   在类里面，方法外面

-   类的属性在没有赋值时是有默认值存在的（拥有默认值的分别为数组和对象的属性）

-   对象属性的初始值和类的定义的默认值一样

### 就近原则

当实例变量和方法中的局部变量相同时，优先使用局部变量，避免这种情况的发生，想使用实例变量可以使用this关键字（直接脱离局部，直接执行实例变量）（this.变量名）

### 栈内存与堆内存

赋值是指向 <https://wenku.baidu.com/view/d3fa64801711cc7930b716e0.html>  

<http://blog.csdn.net/richerg85/article/details/19175133>

-   栈内存：局部变量    

变量名的存储，存放基本数据类型，对象的引用，数组的引用和返回地址，在编译期间完成分配

-   堆内存：实体对象    

只要用到new关键字，就会在堆内存里开辟空间（即：创建对象就会在堆内存中开辟空间，相应的属性也相应的在堆内存中）
对象和数组存在堆区，该区所有线程共享，堆内存中的变量都有默认初始化值，并且对象占有的内存随机分配

-   栈中的变量指向堆内存中的变量，这就是java中的指针

三大特性: 
----------

### 封装:★★★★★  

#### 概念

**是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 **

封装是面向对象的基础，目标是为了实现高内聚低耦合。

类是封装的基本形式，类中包含了属性和方法，属性描述了类的特征，方法描述类的行为。

#### 好处

将变化隔离；便于使用；提高重用性；安全性。 

#### 原则

将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。  

隐藏对象的属性和实现细节，仅对外提供公共访问方式

通过调用setter方法给实例变量赋值，调用getter方法获取实例变量的值

将实例属性标记为私有的

提供公有的 setter和getter方法,用来控制对实例变量的存取动作
注：封装即生成实体类(entity) , vo pojo dto javabean都是实体类

#### 封装的两个含义：

1、把对象的状态和行为看成一个统一的整体，将两者存放在一个独立的模块中（类）

2、信息隐藏。把不需要让外界知道的信息隐藏起来，尽可能隐藏对象功能实现细节，字段。

封装机制在程序中的体现是：把描述对象的状态用字段表示，描述兑现的行为用方法表示，把字段和方法定义在一个类中，并保证外界补鞥呢任意更改其内部的字段值，也不允许调用其内部的功能方法。

指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等程序中的一种体现，通常是讲成员变量私有化，通过对外提供方法，可以对变量进行访问。

boolean类型的变量没有getxxx只有isxxx。
```java
class Person1{

    private String name;

    private int age;

    private int sal;

    public String getName(){

    return name;

  }

  public void set Name(String name){

    this.name = name;

  }

  public int getAge(){

    return age;

  }

  public void setAge(int age){

      this age = age;

    }

}
```

是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

#### 封装原则：

将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。

### 继承  

#### 好处： 

1：提高了代码的复用性。 

2：让类与类之间产生了关系，提供了另一个特征多态的前提。  


#### 注意： 

子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();  

如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。 

如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 

 

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

父类的由来：其实是由多个类不断向上抽取共性内容而来的。

java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。

单继承：一个类只能有一个父类。

多继承：一个类可以有多个父类。

#### 为什么不支持多重继承呢？

因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。

但是java支持多层继承。A继承B B继承C C继承D。

多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。

#### 继承的体系结构

A:多个具体的对象，不断的向上抽取共享的内容，最终形成了一个体系。这个体系叫做继承体系。

B:继承体系的学习和使用原则

\*\*学习顶层的内容。因为他是整个体系的共性内容。

\*\*创建子类使用。也就是使用底层的具体对象。

所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。

简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。

### final特点： 

1：这个关键字是一个修饰符，可以修饰类，方法，变量。

2：被final修饰的类是一个最终类，不可以被继承。 

3：被final修饰的方法是一个最终方法，不可以被覆盖。

 4：被final修饰的变量是一个常量，只能赋值一次。  

### 抽象类的特点： 

1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。 

2：抽象方法只定义方法声明，并不定义方法实现。 

3：抽象类不可以被创建对象(实例化)。 

4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 

5: 抽象类只能单继承。 

### 抽象类的细节： 

1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。

 2：抽象类中是否可以定义非抽象方法？ 

可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 

3：抽象关键字abstract和哪些不可以共存？final , private , static  

4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。

### 多 态★★★★★

函数本身就具备多态性，某一种事物有不同的具体的体现。

体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();

多态的好处：提高了程序的扩展性。

多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)

多态的前提：

1：必须要有关系，比如继承、或者实现。

2：通常会有覆盖操作。 重写

指同一个实体同时具有多种形式。

好比，你去面馆吃面。说我要吃面，那么，老班给我牛肉面，鸡蛋面都可以。

这就是说"面"有多种形态，也就是说实体有多种形态。

编译时的类型由声明该变量时使用的类型决定，运行时的类型由实际赋给变量的对象决定。如果编译时类型和运行时类型不同，就会出现多态。

eg：

前提：student extends Person

Person p = new Person();

Student s = new Student();

//多态

Person P = new Student();

引用关系：父类变量指向子类实例对象。

（面向对象特征之一）：方法本身就具备多态性，某一种事物有不同的具体的体现。

体现：

父类引用或者接口的引用指向了自己的子类对象。//Animal a = new
Cat();父类可以调用子类中覆写过的（父类中有的方法）

好处：

提高了程序的扩展性。继承的父类或接口一般是类库中的东西，（如果要修改某个方法的具体实现方式）只有通过子类去覆写要改变的某一个方法，这样在通过将父类的应用指向子类的实例去调用覆写过的方法就行了！

弊端：

当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)

前提：

1：必须要有关系，比如继承、或者实现。

2：通常会有覆盖操作。

3：父类接口引用指向子类实现对象。

多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。

```JAVA
class 张三{

  void 讲课(){

  System.out.println("企业管理");

  }

  void 钓鱼(){

  System.out.println("钓鱼");

  }

  }

  class 张三三 extends 张三{

  void 讲课(){

  System.out.println("JAVA");

  }

  void 看电影(){

  System.out.println("看电影");

  }

  }

  class {

  public static void main(String[] args) {

  张三 x = new 张三三(); //张三三对象被提升为了张三类型。

  //x.讲课();

  //x.看电影(); //错误.

  张三三 y = (张三三)x; //将张三类型强制转换成张三三类型。

  y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。

  }

}
```
